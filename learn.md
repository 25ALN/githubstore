## 动态规划（一个问题必须拥有最优子结构，才能使用动态规划去解决）
- 动态规划的递推写法总是从这些边界出发，通过状态转移方程扩散到整个dp数组
- 而使用递归写法的计算方式是自顶向下（Top-down Approach），即从目标问题开始，将它分解成子问题的组合，直到分解至边界为止

## 线程与进程

**进程** 是操作系统分配资源的基本单位，代表正在执行的程序实例。每个进程都有自己的内存空间、数据、堆栈以及其它执行资源。进程是操作系统进行资源管理的基本单位。
```
每一个进程都有与其相关的称之为环境列表（environment list）的字符串数组，  
用途: 通过在自身环境中放置变量值，shell 就可确保把这些值传递给其所创建的进程，  
并以此来执行用户命令
```
**线程** 是进程内的一个执行单元，也被称为轻量级进程（LWP）。一个进程可以有多个线程，它们共享进程的资源（如内存、文件描述符等），但每个线程有自己独立的执行栈和寄存器。

## gcc use
编译文件 例：gcc test.c -o test.o
运行文件 ./test.o (此处可传入命令行参数)
在编译时加入 -fsanitize=address 可检查内存泄露 如 gcc -fsanitize=address test.c -o test

## 文件
- 文件句柄
```
文件句柄是操作系统为管理和操作打开文件而分配的标识符。它使程序能够抽象地对文件进行读写操作，  
而不需要直接操作文件系统中的文件路径。操作系统通过文件句柄来管理文件访问权限、资源分配等内容，  
确保程序与文件系统的交互高效且安全.
```

- 文件描述符
```
操作系统中用于标识打开文件的一个整数标识符，它由操作系统为每个打开的文件分配  
文件描述符是操作系统内部使用的一个数字（通常是非负整数），它标识一个进程打开的  
文件或其他输入输出流（如网络连接、管道等）。程序通过文件描述符来与文件进行交互，而不需要直接使用文件路径。
```

- 文件锁
```
一种操作系统提供的机制，用于管理多个进程或线程对同一文件的访问，避免竞争条件和数据不一致性问题。  
在并发环境中，当多个进程同时访问或修改同一个文件时，文件锁可以确保只有一个进程能在某一时刻修改文件内容，
从而避免文件损坏或产生冲突

```
- 符号链接
```
操作系统中的一种特殊类型的文件，它指向另一个文件或目录的位置。它可以被认为是一个“快捷方式”或“别名”，
通过符号链接，用户可以访问或引用另一个文件或目录，而不需要直接操作原始文件或目录

```
- 文件戳
```
文件在文件系统中记录的与文件相关的日期和时间信息

```
- 权限掩码
```
用于在操作系统中控制文件和目录的权限的二进制标志。它通常用于指定谁可以访问文件或目录，  
并决定他们可以执行哪些操作（如读取、写入和执行）。权限掩码通常与用户、组和其他用户的权限相关

```
- 阻塞与非阻塞
```
特性                  阻塞操作                                      非阻塞操作
执行方式      在等待条件满足时，进程或线程会被挂起，暂停执行      操作立即返回，不等待，继续执行后续代码
等待状态      操作会使进程或线程进入等待状态，直到操作完成       操作立即返回，进程或线程不进入等待状态
返回值        操作完成后返回结果                             操作未完成时返回特定的值（如 -1 或 EAGAIN）
常见应用场景   网络 I/O、文件 I/O 操作、进程同步等            非阻塞网络 I/O、异步 I/O、文件操作等

```
- 文件中“a+,r,w,w+"
*w+* 这玩意如果打开一个存在的文件会进行截断，将要写入的内存从头开始覆盖文件原本的内容，
因此一般在创建一个新的文件时用最好；
*a+* 对文件进行追加，并且是换行进行追加
*r* 读写文件中的内容
*w* 单纯允许写入，不可读文件内容

- fprintf与fscanf
*fscanf* 读取文件中的字符串，但在遇到空格与环行符就会停止；
*fprintf* 在文件中另起一行写入内容
```c
int fprintf(FILE* stream, const char* format, ...)
int fscanf(FILE* stream, const char* format, ...);
```
二者都是将数据以字符串的形式存储在文件中
可以利用

## 数据结构
- 栈 (stack)
先进后出
- 队列 (queue)
先进先出
- 哈希表
*uthash* 使用时所需头文件
```c
#include "uthash.h"
```
首先要定义一个结构体
实现见vx.c 2988行

- 二叉树
1.链式二叉树
每个节点最多有两个节点
大多数的思路都是递归，将大问题一个个的化为小问题左右子树进行递归解决问题
且递归的结束条件基本都为当前节点是NULL

## 信号  
1.基本概念
事件发生时对进程的通知机制，分为两大类
a.标准信号(用于内核向进程通知信号)
b.实时信号
2.信号处理器(信号捕捉器)  
指定信号传递给进程时将会调用的一个函数  
3.信号掩码(阻塞信号传递)  
内核会为每个进程维护一个信号掩码，即一组信号，并将阻塞其针对该进程的传递
将遭阻塞的信号发送给某进程，那么对该信号的传递将延后，直至从进程信号掩码中移除
该信号，从而解除阻塞为止
4.信号处理器  
函数 abort()终止其调用进程，并生成核心转储
由于没有对信号排队，故而在为处理器编码时，有时必须要考虑特定类型信号多次发生
的可能性，即使之前信号只产生过一次
可以使用 sigaltstack()来为进程定义备选信号栈  
5.进程的创建
父进程可以使用系统调用 wait()来暂停运行并等待子进程退出
使用fork 大致可以理解实现子进程对父进程数据的复制(其实是复制了描述符)
其所获取的值 大于0则表示当前是父进程，等于0表示是子进程，小于0则表示创建失败
vfork:相比于fork 无需为子进程复制虚拟内存页或页表。相反，子进程共享父进程的内存，直至其成功
执行了 exec()或是调用_exit()退出。
在子进程调用 exec()或_exit()之前，将暂停执行父进程
但他产生的子进程会使用父进程的内存，应尽量避免使用
6.进程的终止
exit()会刷新stdio流缓冲区，相当于在main函数中的返回return
使用atexit()来注册退出处理程序，出错时返回非0值
进程在调用exec()时，会移除所有已注册的退出处理程序
STDOUT_FILENO 是一个常量，它表示标准输出流的文件描述符，搭配write将数据输出在屏幕上
7.监控子进程
```c
#include <sys/wait.h>
pid_t wait(int *status)
```
用其可使父进程监测子进程的终止时间和过程
系统调用 wait()等待调用进程的任一子进程终止，同时在参数 status 所指向的缓冲区中返回
该子进程的终止状态
僵尸进程:无法被信号杀死，删除其的唯一方法就是杀掉他们的父进程
```c
while(waitpid(-1,NULL,WNOHAGN)>0)
  continue;
```
使用上述代码运行至waitpid返回0,表明僵尸进程不再存在(若返回-1则是有错误存在)
SIGCHLD:这个信号通常由操作系统发送给父进程，用来通知它子进程的退出或者停止，或者子进程被暂停或者恢复

8.程序的执行
execve(): 可以将新程序加载到某一进程的内存空间
```c
#include <unistd.h>
int execve(const char *pathname,char *const argv[],char *const envp[]);
// return -1 on error
```

环境变量 PATH
```
函数 execvp()和 execlp()允许调用者只提供欲执行程序的文件名。二者均使用环境变量
PATH 来搜索文件  
PATH 中指定的路径名既可以是绝对路径名（以/开始），也可以是相对路径名。对相对路
径名的诠释是基于调用进程的当前工作目录
```  
getenv  
定义在 <stdlib.h> 头文件中，作用是获取环境变量的值。
- execve
最底层的，其他的exec都是他的变式
```c
#include <unistd.h>

int execve(const char *pathname, char *const argv[], char *const envp[]);
```  
其中需要注意的参数
pathname：要执行的程序的完整路径（如 /bin/ls）。
argv[]：命令行参数数组（类似 main 函数的 argv）。
argv[0] 通常是程序名（如 "ls"）。
argv 的最后一个元素必须是 NULL。
envp[]：环境变量数组（如 {"PATH=/bin", "HOME=/root", NULL}）。
envp 传递新进程的环境变量，如果使用当前进程的环境变量，可以传 environ。
envp 的最后一个元素必须是 NULL
    
- int execl (const char *path, const char *arg, ..., (char *)NULL);
用于执行另一个程序。它属于 进程替换 机制，调用后不会返回，而是直接用新的程序替换当前进程
使用例子: execl("/bin/ls", "ls", "-l", (char *)NULL); 

- clone
因为克隆产生的子进程可能（类似 vfork()）共享父进程的内存，所以它不能使用父进程
的栈

重定向
dup2(fd, STDOUT_FILENO) 将标准输出重定向到文件fd相应的文件，之后所有的输出将不再显示在终端，而是写入文件
0644
创建一个新的文件后赋予一个文件相应的权限
- strtok
使用后如将得到的所分割出来的字符串传出到其他函数可能不能正确分割函数
因此可以使用strtok_r来保存字符串 它不会破坏全局状态
```c
char *strtok_r(char *str, const char *delim, char **saveptr);
```

- pipe
```c
int pipe(int fds[2]);
参数：
fd[0] 将是管道读取端的fd（文件描述符）
fd[1] 将是管道写入端的fd
返回值：0表示成功，-1表示失败。
```
- chdir
可改变当前工作目录
int chdir(const char *path);
## shell相关指令  
```
大于号：将一条命令执行结果（标准输出，或者错误输出，本来都要打印到屏幕上面的）重定向其它输出设备（文件，打开文件操作符，或打印机等等）
小于号：命令默认从键盘获得的输入，改成从文件，或者其它打开文件以及设备输入
>> 是追加内容
> 是覆盖原有内容
```

## 线程
是允许应用程序并发执行多个任务的一种机制  
同一程序中的线程共享一份全局内存
在多线程程序中，每个线程都有属于自己的 errno
- 创建线程
函数 pthread_create()负责创建一条新线程
- 终止线程
pthread_exit()函数将终止调用线程，且其返回值可由另一线程通过调用 pthread_join()来获取
- 线程ID
进程内部的每个线程都有一个唯一标识，称为线程 ID。线程 ID 会返回给 pthread_create()
的调用者，一个线程可以通过 pthread_self()来获取自己的线程 ID
函数 pthread_equal()可检查两个线程的 ID 是否相同
函数 pthread_join()等待由 thread 标识的线程终止。（如果线程已经终止，pthread_join()会
立即返回）。这种操作被称为连接(joining)。(若向其传入一个已经连接的线程ID会出现一些问题)
使用 pthread_detach()，线程可以自行分离
其他线程调用了 exit()，或是主线程执行 return 语句时,进程的所有线程都会终止
**线程与进程间的关键区别在于，线程比进程更易于共享信息**

- 原子操作
不可被中断的操作，即要么完全执行，要么完全不执行，不能被其他线程或进程的操作所干扰
- 互斥量(两种状态锁定与未锁定)
可以使用互斥量来保证对任意共享资源的原子访问，而保护共享变量是其最常见的用法
当超过一个线程加锁同一组互斥量时，就有可能发生死锁
- 条件变量
允许一个线程就某个共享变量（或其他共享资源）的状态变化通知其他线程，并让其他线程等待（堵塞于）这一通知
总是要与一个互斥量相关(见书p533)
动态分配的条件变量应使用pthread_cond_destroy()函数予以销毁

- 线程安全
安全函数：可供多个线程安全调用
pthread_once()可实现一次性初始化

- 线程取消
线程一旦收到取消请求，且启用了取消性状态并将类型置为延迟，则其会在下次抵达取消点时终止
作为一般性原则，可异步取消的线程不应该分配任何资源，也不能获取互斥量或锁

- 信号与线程
对信号的处置属于进程层面，进程中的所有线程共享对每个信号的处置设置
函数 pthread_kill()向同一进程下的另一线程发送信号 sig。目标线程由参数 thread 标识
int pthread_kill(pthread_thread,int sig);
只要有任一线程调用了 exec()系列函数之一时，调用程序将被完全替换。除了调用 exec()的线
程之外，其他所有线程都将立即消失

## 进程间通信
文件锁：文件锁是设计用来协调操作同一文件的多个进程的动作的一种同步方法